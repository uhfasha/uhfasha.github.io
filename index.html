<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一个简单的网页" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 楚盏</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">楚盏</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-java"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/13/java/"
    >java</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/13/java/" class="article-date">
  <time datetime="2023-07-13T02:40:30.000Z" itemprop="datePublished">2023-07-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>定义：被Java赋予了特殊含义的英文单词</p>
<p>关键字特点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">关键字的字母全部小写</span><br><span class="line">常用的代码编辑器，针对关键字有特殊的颜色标记，以直观表示</span><br></pre></td></tr></table></figure>

<p>典型关键字：<strong>class</strong> ：表示定义一个类，后面跟随类名</p>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><table>
<thead>
<tr>
<th align="center">字面量类型</th>
<th align="center">说明</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数类型(int)</td>
<td align="center">不带小数点的数字</td>
<td align="center">666，-88</td>
</tr>
<tr>
<td align="center">小数(浮点数)类型(double)</td>
<td align="center">带小数点的数字</td>
<td align="center">13.14，-5.21</td>
</tr>
<tr>
<td align="center">字符串类型(String)</td>
<td align="center">用双引号括起来的内容</td>
<td align="center">“Hello”</td>
</tr>
<tr>
<td align="center">字符类型</td>
<td align="center">用单引号括起来的，内容只能有一个</td>
<td align="center">‘A’，‘0’，‘我’</td>
</tr>
<tr>
<td align="center">布尔类型(bool)</td>
<td align="center">布尔值，表示真假</td>
<td align="center">只有“true”,”false’’</td>
</tr>
<tr>
<td align="center">空类型</td>
<td align="center">一个特殊的值，空值</td>
<td align="center">唯一一个值：null</td>
</tr>
</tbody></table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在程序的执行过程中，值有可能变化的量(数据)</p>
<h4 id="变量使用场景"><a href="#变量使用场景" class="headerlink" title="变量使用场景"></a>变量使用场景</h4><p>当摸个数据经常发生改变时,我们可以用变量来存储.当数据变化时,只需要改变变量里面记录的值即可</p>
<h4 id="变量使用方式"><a href="#变量使用方式" class="headerlink" title="变量使用方式"></a>变量使用方式</h4><p>输出打印，参与计算，修改记录的值</p>
<h4 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h4><p>数据类型 变量名 &#x3D;数据值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型:为空间中存储的数据,加入类型[限制]小数,整数</span><br><span class="line">变量名:为空间起的名字,方便后续使用	</span><br><span class="line">数据值:存在(空间)变量里面的数值</span><br></pre></td></tr></table></figure>

<h4 id="变量的注意事项"><a href="#变量的注意事项" class="headerlink" title="变量的注意事项"></a>变量的注意事项</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只能存一个值</span><br><span class="line">变量名不允许重复定义</span><br><span class="line">一条语句可以定义多个变量</span><br><span class="line">变量在使用之前一定要先进行赋值</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">内存占用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整数</td>
<td align="center">byte</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">整数</td>
<td align="center">short</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">整数</td>
<td align="center">int</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">整数</td>
<td align="center">long</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">浮点数</td>
<td align="center">float</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">浮点数</td>
<td align="center">double</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">字符</td>
<td align="center">char</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">布尔</td>
<td align="center">boolean</td>
<td align="center">1</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果要定义一个long类型变量，要在数据最后加上一个L作为后缀(建议使用大写L来便于区分)</span><br></pre></td></tr></table></figure>

<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符：就是我们自己给类，方法，变量起的名字</p>
<h4 id="标识符命名规则-—-硬性要求"><a href="#标识符命名规则-—-硬性要求" class="headerlink" title="标识符命名规则 — 硬性要求"></a>标识符命名规则 — 硬性要求</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">由数字，字母，下划线(_)和美元符($)组成</span><br><span class="line">不能以数字开头</span><br><span class="line">不能是关键字</span><br><span class="line">区分大小写</span><br></pre></td></tr></table></figure>

<h4 id="标识符命名规则-—-软性建议"><a href="#标识符命名规则-—-软性建议" class="headerlink" title="标识符命名规则 — 软性建议"></a>标识符命名规则 — 软性建议</h4><p>1.小驼峰命名法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适用于:方法、变量</span><br><span class="line">规范1:标识符是一个单词的时候，全部小写</span><br><span class="line">范例1: name</span><br><span class="line">规范2:标识符由多个单词组成的时候，第一个单词首字母小写，其他单词首字母大写</span><br><span class="line">范例2: firstName</span><br></pre></td></tr></table></figure>

<p>2.大驼峰命名法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适用于:类名</span><br><span class="line">规范1:标识符是-个单词的时候，首字母大写</span><br><span class="line">范例1: Student</span><br><span class="line">规范2:标识符由多个单词组成的时候，每个单词的首字母大写</span><br><span class="line">范例2: GoodStudent</span><br></pre></td></tr></table></figure>

<p><strong>遵守一个准则：见名知意</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-http协议"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/11/http%E5%8D%8F%E8%AE%AE/"
    >http协议</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/11/http%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2023-07-11T02:54:05.000Z" itemprop="datePublished">2023-07-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="什么是http协议"><a href="#什么是http协议" class="headerlink" title="什么是http协议"></a>什么是http协议</h3><p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。允许将超文本标记语言(HTML)文档总web服务器传送到客户端的浏览器</p>
<h3 id="http概述"><a href="#http概述" class="headerlink" title="http概述"></a>http概述</h3><p>http是一个由客户端终端(用户)和服务器端(网站)请求和应答的标准(TCP)<br>常见的网络协议都是在(TCP&#x2F;IP)的基础上进行的，可以理解为是TCP&#x2F;IP的子集</p>
<h3 id="http工作原理"><a href="#http工作原理" class="headerlink" title="http工作原理"></a>http工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端</p>
<h3 id="对TCP-x2F-IP的理解"><a href="#对TCP-x2F-IP的理解" class="headerlink" title="对TCP&#x2F;IP的理解"></a>对TCP&#x2F;IP的理解</h3><p>目前有三种说法:<br>1.将所有互联网协议组合起来就是TCP&#x2F;IP<br>2.TCP&#x2F;IP指TCP和IP两种协议的组合<br>3.认为TCP&#x2F;IP是在IP通信中用到的协议族统称<br>尽管TCP&#x2F;IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP&#x2F;IP协议族使用TCP作为其传输层。</p>
<h4 id="TCP-x2F-IP协议的重要特征-分层管理"><a href="#TCP-x2F-IP协议的重要特征-分层管理" class="headerlink" title="TCP&#x2F;IP协议的重要特征:分层管理"></a>TCP&#x2F;IP协议的重要特征:分层管理</h4><p>TCP&#x2F;IP协议族是由一个四层协议组成的系统,这四层分别为:应用层.传输层.网络层和数据链路层</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用层:一般是我们编写的应用程序,决定了向用户提供的应用服务.应用层可以通过系统调用与传输层进行通信,如:FTP.DNS.HTTP等</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传输层:通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能,在传输层有两个心志不同的协议:TCP和UDP</span><br><span class="line">TCP是面向连接的,可靠但效率低(由于建立了连接)</span><br><span class="line">UDP是无连接的，不可靠但效率高(由于没有建立连接)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络层:用来处理在网络上流动的数据包,数据包是网络传输的最小数据单位.该层规定了通过怎样的路径(传输路线)到达对方的电脑,并且把数据包传递给对方</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链路层:用来处理连接网络的硬件部分,包括控制操作系统的硬件设备驱动.NIC,以及光纤等物理可见部分.硬件上的范畴均在链路层的作用范围之内.</span><br></pre></td></tr></table></figure>

<h3 id="HTTP数据传输过程"><a href="#HTTP数据传输过程" class="headerlink" title="HTTP数据传输过程"></a>HTTP数据传输过程</h3><p>发送端发送数据时，数据会从上层传输到下层，且每经过一层都会被打上该层的头部信息。而接收端接收数据时，数据会从下层传输到上层，传输前会把下层的头部信息删除</p>
<h3 id="传输层-—-TCP三次握手"><a href="#传输层-—-TCP三次握手" class="headerlink" title="传输层 —-TCP三次握手"></a>传输层 —-TCP三次握手</h3><p>使用TCP协议进行通信的双方必须先建立连接,然后才可以开始传输数据.为了确保莲接双方的可靠性,在双方建立连接时,TCP协议采用了三次握手策略</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一次握手:客户端发送带有SYN标志的连接请求报文段,然后进入SYN_SEND状态,等待服务端的确认</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第二次握手:服务端接收到客户端的SYN报文段后需要发送ACK信息对这个SYN报文段进行确认。</span><br><span class="line">同时，还要发送自己的SYN请求信息。服务端会将上述的信息放到一个报文段(SYN+ACK报文段)中，一并发送给客户端此时服务端将会进入SYN_RECV状态。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第三次握手:客户端收到服务端的SYN+ACK报文段后,会向服务端发送ACK确认报文段,这个报文段发送完毕后,客户端和服务端都进入ESTABLISHED状态,完成三次握手</span><br></pre></td></tr></table></figure>

<h3 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h3><p>通常我们访问一 个网站，使用的是主机名或者域名来进行访问的。因为相对于IP地址(一 -组纯数字)，域名更容易让 人记住。但TCP&#x2F;IP协议使用的是IP地址进行访问的，所|以必须有个机制或服务把域名转换成IP地址。DNS服务就是用来解决这个问题的，它提供域名到IP地址之间的解析服务。</p>
<h3 id="Web与HTTP"><a href="#Web与HTTP" class="headerlink" title="Web与HTTP"></a>Web与HTTP</h3><p>◆WEB是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统</p>
<p>◆建立在Internet 上的一-种网络服务，为浏览者在Internet.上查找和浏览信息提供了图形化的、易于访问的直观界面，其中的文档及超级链接将Internet.上的信息节点组织成一个互为关联的网状结构</p>
<h3 id="回溯HTTP事务处理过程"><a href="#回溯HTTP事务处理过程" class="headerlink" title="回溯HTTP事务处理过程"></a>回溯HTTP事务处理过程</h3><p>当客户端访问Web站点时，首先会通过DNS服务查询到域名的IP地址。然后浏览器生成HTTP请求，并通过TCP&#x2F;IP协议发送给Web服务器。Web服务器接收到请求后会根据请求生成响应内容,并通过TCP&#x2F;IP协议返回给客户端。</p>
<h3 id="熟悉HTTP协议结构和通讯原理"><a href="#熟悉HTTP协议结构和通讯原理" class="headerlink" title="熟悉HTTP协议结构和通讯原理"></a>熟悉HTTP协议结构和通讯原理</h3><h4 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h4><p>1.支持客户&#x2F;服务器模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户/服务器模式工作的方式是由客户端向服务器发出请求,服务器端响应请求,并进行相应服务</span><br></pre></td></tr></table></figure>

<p>2.简单快速</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户向服务器请求服务时,只需传送请求方法和路径</span><br><span class="line">请求常用方法有GET,HEAD,POST,每种方法规定了客户与服务区联系单类型不同</span><br><span class="line">由于HTTP协议简单,使得HTTP服务器程序规模小,响应更快捷,通信速度更快</span><br></pre></td></tr></table></figure>

<p>3.灵活</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP允许传输任意类型的数据对象</span><br><span class="line">正在传输的类型由Content-Type(Content-Type是HTTP中用来表示内容类型的标识)加以标记</span><br></pre></td></tr></table></figure>

<p>4.无连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无连接的含义是限制每次连接只处理一个请求</span><br><span class="line">服务器处理完客户的请求,并收到客户的应答后,即断开连接</span><br><span class="line">采用这种方式可以节省传输时间</span><br></pre></td></tr></table></figure>

<p>5.无状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP协议是无状态协议</span><br><span class="line">无状态是指协议对于食物处理的没有记忆能力,缺少状态意味着如果后续处理需要前面的信息,则它必须重传，这样可能导致每次连接传送的数据量增大</span><br><span class="line">(在服务器需要处理之前的信息时会很慢,但是在处理新传来的信息就会很快)</span><br></pre></td></tr></table></figure>

<h3 id="URI与URL"><a href="#URI与URL" class="headerlink" title="URI与URL"></a>URI与URL</h3><p>URI：一个紧凑的字符串用来标示抽象或物理资源</p>
<p>URL可以理解为URI的一个子集，除了确定一个资源，还提供了一种定位该资源的主要网络访问机制（如其网络“位置”）</p>
<p>一个URI可以进一步被分为定位符，名字或两者都是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">◆URI可以分为URL,URN或同时具备locators和names特性的一个东西</span><br><span class="line">◆URN作用就好像一个人的名字，URL就像一个人的地址</span><br><span class="line">◆换句话说: URN确定了东西的身份，URL提供了找到它的方式</span><br></pre></td></tr></table></figure>

<h4 id="URL与URI辨析"><a href="#URL与URI辨析" class="headerlink" title="URL与URI辨析"></a>URL与URI辨析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL是URI的一种，但不是所有的URL都是URI</span><br><span class="line">URL与URI最大的区别是特殊的访问机制</span><br><span class="line">URN是唯一表示的一部分，是身份信息</span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-C语言笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/09/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"
    >C语言笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/09/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-07-09T14:17:19.000Z" itemprop="datePublished">2023-07-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="c语言心得"><a href="#c语言心得" class="headerlink" title="c语言心得"></a>c语言心得</h2><ol>
<li>头文件为#include&lt;stdio.h&gt;<br>2.不用写 using namespace std;<br>3.输出由cout变为printf，输出double类型变量时用%f，int类型变量时用%d<br>4.换行由endl变为\n<br>5.输入由cin变为scanf，连续输入多个数值时%d之间不用加逗号<br>6.输入输出时在变量前加&amp;<br>7.在单目不变或单目取负时+，—的优先级高于*，&#x2F; 运算顺序为由右向左 （单目指只有一个算子）<br>8.c具备很多格式符e.g:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\a        报警声（*）</span><br><span class="line">\b        退格（删除）</span><br><span class="line">\f        换页</span><br><span class="line">\n        换行</span><br><span class="line">\r        回车（回到本行开头）//\n和\r是两个不同的特殊逃逸字符</span><br><span class="line">\t        水平制表（使后面的数从最接近8的倍数处开始输入，固定在某个位置而不是股固定的字符数量）</span><br><span class="line">\v        垂直制表（使其后面的数从下一行开始输入）</span><br><span class="line">\’        单引号（单引号一个数代表一个字符&lt;ASC||码&gt;）</span><br><span class="line">\”        双引号（与c++一样）</span><br><span class="line">\\        反斜杠（用于一行末尾，代表这行与下一行连接起来，也可不写）</span><br><span class="line">\ooo     1-3位八进制数所代表的字符</span><br><span class="line">\xhh     1-2位十六进制数所代表的的字符</span><br></pre></td></tr></table></figure>
9.const int 指定义一个不可修改的常量，在初始化之后再修改其值会报错<br>10.递增递减运算符”++,–”也是单目运算符，分为前缀型和后缀型<br>举例如下：假设a的初始值为10；则a++&#x3D;10；a&#x3D;11；++a&#x3D;12；a&#x3D;12（++a处由于第一次运算时在a上加了一，故呈现出加了2的感觉，实际仍是加一）<br>11.判断条件基本等价于c++中bool类型变量，可直接用printf(…)表示，成立输出值就为1，否则为0，若要使用bool变量类型也可以引入头文件#include&lt;stdbool.h&gt;.<br>e.g：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> #include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;,6&gt;5&gt;4);//6&gt;5判定为真，值转化1，而1小于4，故结果为0 </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
12.在if和else后要习惯性加上{}来防止if和else主观上配对错误<br>13.在switch-case语句中switch后跟的数必须是int类型，且case后跟的为常数，否则没有意义，<br>case不是分割Switch的，如果在第一个case中没有遇到break就直接进入下一个case，直到遇见break为止，最后若没有值与case中任一一值相等（没有值与case相等）则用default来作为最后一个case分支结构<br>14.do-while语句和while语句基本等同于c++，一定记住do-while循环语句中while后要加上一个分号（代表语句的结束）<br>记住do-while语句最少要进行一次循环而while语句最少可以有0次循环<br>15.在scanf这个格式输入符中加入非格式字符时在输入数据时也需要加入这些非格式字符，否则将会报错，e.g：<br><strong>scanf(“a&#x3D;%d,b&#x3D;%d”,&amp;a,&amp;b);</strong><br><strong>输入时需要输入a&#x3D;… ,b&#x3D;…</strong><br>16.c语言中产生随机数的程序与c++近似相同，只在头文件上存在一定区别<br>17.循环如果有固定次数则用for，必须执行一次则用do-while，其余都建议用while语句（简洁且不易错）<br>18.break是跳出循环，continue是跳过这次循环剩下的语句直接进入下一轮循环（都只能对所在的那一层循环起作用）在循环的嵌套中连续使用break以跳出全部循环结构的称为接力break以一个凑钱的小程序直观体现e.g：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int one,two,five;//这三个都是分别代表三种数额各自的数量 </span><br><span class="line">    int exit=0;//等价于bool变量 </span><br><span class="line">    printf(&quot;输入需要凑的值x=&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">    for(one=1;one&lt;x*10;one++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(two=1;two&lt;x*10/2;two++)//此处two仅仅代表数量，故从一开始计数 </span><br><span class="line">        &#123;</span><br><span class="line">            for(five=1;five&lt;x*10/5;five++)</span><br><span class="line">            &#123;</span><br><span class="line">            if(one+two*2+five*5==x*10)//将个数转化为对应的钱 </span><br><span class="line">                &#123;</span><br><span class="line">                 printf(&quot;可以用%d个一角%d个两角%d个五角凑出%d元\n&quot;,one,two,five,x);</span><br><span class="line">                 exit=1;</span><br><span class="line">                 break;//跳出该层循环 </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;if(exit) break;//跳出该层循环 </span><br><span class="line">        &#125;if(exit) break;//跳出该层循环(作为最后一个break同时也意味着跳出所有循环),这是只要有一种方案就结束程序的情况</span><br><span class="line">    //也可以不用加入bool变量，直接在最后一个printf处将break替换为goto 加上一个任意字符；并删除其余的break </span><br><span class="line">    &#125; </span><br><span class="line">        /*若在前面使用了goto ，则需在此处加上该任意字符：*/return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
19.在做数的分解时可以习惯用do-while循环，可以有效解决特殊值0的问题<br>20.在C语言环境中没有n次方的语句，记得利用一个循环来有效代替<br>21.在做数字对应输出字符时，考虑使用<strong>Switch-case</strong>结构来进行输出，可以减少很多绕路<br>22.逃逸字符：用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠“\”开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符<br>23.大小写转换：字母在ASCII表中是顺序排列的大写字母和小写字母是分开排列的，并不在一起，’a’-‘A’’可以得到两段之间的距离，于是a+’a’-‘A”可以把一个大写字母变成小写字母，反之则可以把一个大写字母变成小写<br>24.当判断一个字符是否为大写字母时，可以利用逻辑运算符“&amp;&amp;”来判断，e.g:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(c&gt;&#x27;A&#x27;&amp;&amp;c&lt;&#x27;Z&#x27;)//使用单引号来框住大写字母</span><br><span class="line">printf(&quot;1\n&quot;);</span><br></pre></td></tr></table></figure>
25.不要把赋值，包括复合赋值写进表达式，防止出现短路情况<br>26.逻辑运算符的优先级为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    优先级       运算符                 结合性</span><br><span class="line">    1            ()                    从左到右</span><br><span class="line">    2            !+–++--               从右到左（单目的+和-)</span><br><span class="line">    3            */%                   从左到右</span><br><span class="line">    4            +-                    从左到右</span><br><span class="line">    5            &lt;&lt;=&gt;&gt;=                从左到右</span><br><span class="line">    6            == !=                 从左到右</span><br><span class="line">    7            &amp;&amp;                    从左到右</span><br><span class="line">    8            ||                    从左到右</span><br><span class="line">    9            += -= *= /= %=        从右到左</span><br><span class="line">在逻辑运算中如果前面的结果已经可以决定结果了就不会再进行下去 </span><br></pre></td></tr></table></figure>
27.条件表达式中”?”前的条件如果满足就输出”?”后面”:”前面的数，否则输出”:”后面的数（不要用嵌套的条件表达式来赋值，会十分的混乱）<br>28.逗号运算：逗号运算会先计算左边的表达式，但会输出逗号后面一个表达式的值，但由于逗号运算的优先级非常的低，比赋值运算”&#x3D;”的优先级还低，所以在用到逗号运算时最好在两个表达式外加上一个括号(一般只有在for循环中才会用到)<br>29.尽量避免”代码复制”，这种代码不良的体现，因为在维护时会进行很多处的修改，会很麻烦，可以通过定义一个函数来避免代码的不断复制<br>30.C语言的运算符主要有以下几类:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(1)算术运算符:+、-、*、/、%。</span><br><span class="line">(2)关系运算符: &gt;、&lt;&gt;=、 &lt;=、 !=、==。</span><br><span class="line">(3)逻辑运算符: !、&amp;&amp;、ll。</span><br><span class="line">(4)位运算符: &amp;、|、^ &lt;&lt;、&gt;&gt;。</span><br><span class="line">(5)赋值运算符:=、++、、+=、-=、*=、/=、%=、&amp;=、|=、^=、&lt;&lt;=、&gt;&gt;=。</span><br><span class="line">(6)条件运算符: 2:。</span><br><span class="line">(7)求字节数运算符: (sizeof)。</span><br><span class="line">(8) 强制类型转换运算符: (类型)(如(int)、 (int *)、(float)、 (char)等)。</span><br><span class="line">(9) 逗号运算符:,</span><br><span class="line">(10)数组下标运算符: []。</span><br><span class="line">(11)成员引用运算符: .  -&gt;。</span><br><span class="line">(12) 指针运算符: * &amp;。</span><br><span class="line">运算符也可以叫作操作符。有运算符就需要有运算数(操作数)，如+的运算就需要在该运算符两侧出现两个数据来进行运算</span><br></pre></td></tr></table></figure>
31.对于有多次输入的程序，如果希望本次输入语句重新从键盘读取数据（不适用之前输入的剩余在缓冲区得到数据），可以在本次输入语句之前加一条**fflush(stdin)**来清除缓冲区数据<br>32.递归中循环一定可以用递归，递归不一定循环，其分为递归入口和出口（用于区分不同但相似的循环程序）<br>33.对于定义函数中变量的一些知识点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">本地变量的规则:</span><br><span class="line">本地变量是定义在块内的</span><br><span class="line">它可以是定义在函数的块内</span><br><span class="line">也可以定义在语句的块内</span><br><span class="line">甚至可以随便拉一对大括号来定义变量</span><br><span class="line">程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了，在块外面定义的变量可以存在于块里面</span><br><span class="line">在块内定义了和块外同名的变量在块内运行时会覆盖掉块外的变量！！！</span><br><span class="line">在同一个块里不能定义同名变量</span><br><span class="line">本地变量不会被定义初始化</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int i,j,sum(int a,int b)</span><br><span class="line">return (i);</span><br><span class="line">涉及两个知识点</span><br><span class="line">&#123;</span><br><span class="line">1.逗号运算：sum(int a,int b)中外层一个括号代表需要输入两个int类型变量，若变为sum((int a,int b))则需先进行逗号运算</span><br><span class="line">2.这代码意义为定义两个int类型变量并声明一个函数sum，sum函数需要输入两个int类型变量并且返还值为一个int类型变量&#123;return (i)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解:"></a>初步理解:</h3><p><strong>一般用数组的首元素地址来标识一个数组，则输出数组首元素地址,及首元素地址可代表数组地址,同理输出数组地址时输出的也是首元素的地址</strong><br>type_t   arr_name   [const_n];<br>&#x2F;&#x2F;type_t 是指数组的元素类型<br>&#x2F;&#x2F;const_n 是一个常量表达式，用来指定数组的大小</p>
<p> #define X 3<br>int arr5[X];&#x2F;&#x2F;用宏定义的方式</p>
<p><strong>错误使用</strong>：<br>int count &#x3D; 10;<br>int arr6[count];&#x2F;&#x2F;在[]中除非使用<strong>宏定义</strong>的方式，不然只能使用常量</p>
<h3 id="基本结论"><a href="#基本结论" class="headerlink" title="基本结论"></a>基本结论</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数组是具有相同类型的集合，数组的大小（即所占字节数）由元素个数乘以单个元素的大小。</span><br><span class="line">数组只能够整体初始化，不能被整体赋值。只能使用循环从第一个逐个遍历赋值。</span><br><span class="line">初始化时，数组的维度或元素个数可忽略 ，编译器会根据花括号中元素个数初始化数组元素的个数。</span><br><span class="line">当花括号中用于初始化值的个数不足数组元素大小时，数组剩下的元素依次用0初始化。</span><br><span class="line">字符型数组在计算机内部用的时对应的ascii码值进行存储的。</span><br><span class="line">一般用”“引起的字符串，不用数组保存时，一般都被直接编译到字符常量区，并且不可被修改。</span><br></pre></td></tr></table></figure>
<p>1.int number[100] 代表定义了一个数组number其中每一个单元都是一个int类型的变量，单元个数由number后括号内的值决定，数组大小在定义后就不能改变，其中所有字符类型相同，且每个内存中的数均按照输入顺序排列，不可以改变<br>2.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定义数组</span><br><span class="line">&lt;类型&gt;变量名称[元素数量];</span><br><span class="line">int grades[100];//int 为定义这个数组里的字符为int类型</span><br><span class="line">double weight[20];//double 为定义这个数组里的字符为double类型</span><br><span class="line">元素数量必须是整数</span><br><span class="line">c99之前:元素数量必须是编译时刻确定的字面量//尽量用常量来定义，避免由于兼容问题报错</span><br><span class="line">一般下标从0开始，所以得 习惯从0开始计数</span><br><span class="line">最大的下标是定义的数组的值减一，如int number[100]最小的下标为0，最大的为99，超出数组下标系统不会报错，但是会导致程序崩溃</span><br></pre></td></tr></table></figure>
<p>3.(仅限c99)在避免用户输入的数超出数组定义的范围时，可以使用变量来定义一个数组的单元数量<br>4.数组单元数可以为0，可以存在，但无用(不存在有效下标)<br>5.数组初始化可以用int a[ ]{1,2,3,4,5,6,7,8} 来表示，其中定义数组的方括号内不放值<br>6.**sizeof()**可以求一个变量的字节数，所以可以用sizeof(a)&#x2F;&#x2F;a为数组&#x2F;sizeof(a[ ])来求这个数组一共有多少个单元格<br>7.不能直接将一个数组赋值给另外一个数组，只能使用遍历来进行数组的赋值(通常都是用for循环，从零开始到小于数组的长度，使得结束时的下标刚好在有效下标内，不会导致程序崩溃，切记离开循环后不可以用该循环变量来做数组下标，由于该变量初始值在循环结束后刚好变为无效变量，会导致程序崩溃)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    b[i]=a[i]//将每一个a数组的值覆给b数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.二维数组表示为 a[i][j]，其遍历需要用到循环的嵌套e.g:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(i=0;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">    for(j=1;j&lt;5;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i][j]=i*J//等价于一个5阶矩阵</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9.在检查数组错误时，可以加一个断言<strong>assert(i&gt;&#x3D;1&amp;&amp;i&lt;&#x3D;10)</strong>&#x2F;&#x2F;静态调试&#x2F;&#x2F;用来检测数组下标，在错误时程序运行时会在运行框中会体现出来<br>10.二维数组的初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a[][5]=&#123;</span><br><span class="line">    &#123;0,1,2,3,4&#125;,</span><br><span class="line">    &#123;0,1,2,3,4&#125;,</span><br><span class="line">&#125;</span><br><span class="line">其中列数必须写，行数可以让编译器来数</span><br><span class="line">每行一个&#123;&#125;由&quot;,&quot;来分隔</span><br><span class="line">赋值最后的逗号可以存在，这是一个古老的传统</span><br><span class="line">如果省略，表示补零</span><br><span class="line">也可以用定位(c99 only)</span><br></pre></td></tr></table></figure>
<p><strong>输出二位数组完整程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    int j=0;</span><br><span class="line">    int arr[3][4]=&#123;&#123;1,2,3&#125;,&#123;1,2,3,4&#125;&#125;;</span><br><span class="line">    for(i=0;i&lt;=3;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(j=0;j&lt;=4;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            printf(&quot;arr[%d][%d]=%d&quot;,i,j,arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一维数组降维成指针"><a href="#一维数组降维成指针" class="headerlink" title="一维数组降维成指针"></a>一维数组降维成指针</h3><p>ps:加了&amp;的shuzu代表整个数组，&amp;shuzu+1代表的是跳过整个数组，而shuzu+1代表的是数组中的下一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void Lisa(int arr[])</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;a = %d\n&quot;, sizeof(arr));//数组降维成指针后的指针大小，在32位系统下指针都为4字节</span><br><span class="line">        printf(&quot;b = %d\n&quot;, sizeof(arr[0]));//数组首元素的大小</span><br><span class="line">        printf(&quot;sz =a / b  = %d\n&quot;, sizeof(arr) / sizeof(arr[0]));//大小为1</span><br><span class="line">        printf(&quot;arr = %p\n&quot;, arr);//数组首元素地址</span><br><span class="line">        printf(&quot;&amp;arr = %p\n&quot;, &amp;arr);//指针的地址</span><br><span class="line">        printf(&quot;arr + 1 = %p\n&quot;, arr + 1);//下一个元素的地址</span><br><span class="line">        printf(&quot;&amp;arr + 1 = %p\n&quot;, &amp;arr + 1);//指针下一项的地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int Shuzu[10] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;;</span><br><span class="line">        printf(&quot;a = %d\n&quot;, sizeof(Shuzu));//数组总大小</span><br><span class="line">        printf(&quot;b = %d\n&quot;, sizeof(Shuzu[0]));//数组首元素大小</span><br><span class="line">        printf(&quot;sz =a / b = %d\n&quot;, sizeof(Shuzu) / sizeof(Shuzu[0]));//数组元素个数</span><br><span class="line">        printf(&quot;Shuzu = %p\n&quot;, Shuzu);//数组首元素地址</span><br><span class="line">        printf(&quot;&amp;Shuzu = %p\n&quot;, &amp;Shuzu);//代表整个数组，但是地址仍是首元素地址</span><br><span class="line">        printf(&quot;Shuzu + 1 = %p\n&quot;, Shuzu + 1);//下一个元素的地址</span><br><span class="line">        printf(&quot;&amp;Shuzu + 1 = %p\n&quot;, &amp;Shuzu + 1);//跳过整个数组后紧挨着的地址</span><br><span class="line">                                                               //此时该地址减去首元素地址等于数组大小</span><br><span class="line">        printf(&quot;\n\n&quot;);</span><br><span class="line">        Lisa(Shuzu);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组降维成指针"><a href="#二维数组降维成指针" class="headerlink" title="二维数组降维成指针"></a>二维数组降维成指针</h3><p>ps:加了&amp;的shuzu代表整个数组，&amp;shuzu+1代表的是跳过整个数组，而shuzu+1代表的是数组中的下一个元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void Lisa(int arr[][4])</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;a = %d\n&quot;, sizeof(arr));//数组降维成指针后的指针大小，在32位系统下指针都为4字节</span><br><span class="line">        printf(&quot;b = %d\n&quot;, sizeof(arr[0][0]));//数组首元素的大小</span><br><span class="line">        printf(&quot;sz =a / b  = %d\n&quot;, sizeof(arr) / sizeof(arr[0][0]));//大小为1</span><br><span class="line">        printf(&quot;arr = %p\n&quot;, arr);//数组首元素地址</span><br><span class="line">        printf(&quot;arr + 1 = %p\n&quot;, arr + 1);//下一个元素的地址</span><br><span class="line">        printf(&quot;&amp;arr = %p\n&quot;, &amp;arr);//指针的地址</span><br><span class="line">        printf(&quot;&amp;arr + 1 = %p\n&quot;, &amp;arr + 1);//指针下一项的地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int Shuzu[3][4] = &#123; 0,1,2,3,4,5,6,7,8,9 &#125;;</span><br><span class="line">        printf(&quot;a = %d\n&quot;, sizeof(Shuzu));//数组总大小</span><br><span class="line">        printf(&quot;b = %d\n&quot;, sizeof(Shuzu[0][0]));//数组首元素大小</span><br><span class="line">        printf(&quot;sz =a / b = %d\n&quot;, sizeof(Shuzu) / sizeof(Shuzu[0][0]));//数组元素个数</span><br><span class="line">        printf(&quot;Shuzu = %p\n&quot;, Shuzu);//数组首元素地址</span><br><span class="line">        printf(&quot;Shuzu + 1 = %p\n&quot;, Shuzu + 1);//下一个元素的地址,这时其内部元素的一维数组</span><br><span class="line">        printf(&quot;&amp;Shuzu = %p\n&quot;, &amp;Shuzu);//代表整个数组，但是地址仍是首元素地址</span><br><span class="line">        printf(&quot;&amp;Shuzu + 1 = %p\n&quot;, &amp;Shuzu + 1);//跳过整个数组后紧挨着的地址</span><br><span class="line">                                                //此时该地址减去首元素地址等于数组大小</span><br><span class="line">        printf(&quot;\n\n&quot;);</span><br><span class="line">        Lisa(Shuzu);</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">个人认为从名字区分可以看后面部分，后面是数组则代表这是一个数组，反之则代表这是一个指针</span><br></pre></td></tr></table></figure>
<p>数组指针：是指针，指向数组。例：int (*arr)[10]<br>对其的理解:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //一维数组</span><br><span class="line">    int a[5] = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">    //步长为5的数组指针，即数组里有5个元素</span><br><span class="line">    int (*p)[5];</span><br><span class="line">    //把数组a的地址赋给p，则p为数组a的地址，则*p表示数组a本身</span><br><span class="line">    p = &amp;a;</span><br><span class="line"> </span><br><span class="line">    //%p输出地址, %d输出十进制</span><br><span class="line">    //\n回车</span><br><span class="line">    //在C中，在几乎所有使用数组的表达式中，数组名的值是个指针常量，也就是数组第一个元素的地址，它的类型取决于数组元素的类型。</span><br><span class="line">    printf(&quot;%p\n&quot;, a); //输出数组名，一般用数组的首元素地址来标识一个数组，则输出数组首元素地址</span><br><span class="line">    printf(&quot;%p\n&quot;, p); //根据上面，p为数组a的地址，输出数组a的地址</span><br><span class="line">    printf(&quot;%p\n&quot;, *p); //*p表示数组a本身，一般用数组的首元素地址来标识一个数组</span><br><span class="line">    printf(&quot;%p\n&quot;, &amp;a[0]); //a[0]的地址</span><br><span class="line">    printf(&quot;%p\n&quot;, &amp;a[1]); //a[1]的地址</span><br><span class="line">    printf(&quot;%p\n&quot;, p[0]); //数组首元素的地址</span><br><span class="line">    printf(&quot;%d\n&quot;, **p); //*p为数组a本身，即为数组a首元素地址，则*(*p)为值，当*p为数组首元素地址时，**p表示首元素的值1</span><br><span class="line">    printf(&quot;%d\n&quot;, *p[0]); //根据优先级，p[0] 表示首元素地址，则*p[0]表示首元素本身，即首元素的值1</span><br><span class="line">    printf(&quot;%d\n&quot;, *p[1]); //为一个绝对值很大的负数，不表示a[1]...表示什么我还不知道</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    //将二维数组赋给指针</span><br><span class="line">    int b[3][4];</span><br><span class="line">    int(*pp)[4]; //定义一个数组指针，指向含4个元素的一维数组</span><br><span class="line">    pp = b; //将该二维数组的首地址赋给pp，也就是b[0]或&amp;b[0]，二维数组中pp=b和pp=&amp;b[0]是等价的</span><br><span class="line">    pp++; //pp=pp+1，该语句执行过后pp的指向从行b[0][]变为了行b[1][]，pp=&amp;b[1]</span><br><span class="line"> </span><br><span class="line">    int k;</span><br><span class="line">    scanf_s(&quot;%d&quot;, &amp;k);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针数组：是数组，数组内容存放的是指针。例：int *arr[10]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    int *p[2];</span><br><span class="line">    p[0] = &amp;a;</span><br><span class="line">    p[1] = &amp;b;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;%p\n&quot;, p[0]); //a的地址</span><br><span class="line">    printf(&quot;%p\n&quot;, &amp;a); //a的地址</span><br><span class="line">    printf(&quot;%p\n&quot;, p[1]); //b的地址</span><br><span class="line">    printf(&quot;%p\n&quot;, &amp;b); //b的地址</span><br><span class="line">    printf(&quot;%d\n&quot;, *p[0]); //p[0]表示a的地址，则*p[0]表示a的值</span><br><span class="line">    printf(&quot;%d\n&quot;, *p[1]); //p[1]表示b的地址，则*p[1]表示b的值</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //将二维数组赋给指针数组</span><br><span class="line">    int *pp[3]; //一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]，所以要分别赋值</span><br><span class="line">    int c[3][4];</span><br><span class="line">    for (int i = 0; i&lt;3; i++)</span><br><span class="line">        pp[i] = c[i];</span><br><span class="line"> </span><br><span class="line">    int k;</span><br><span class="line">    scanf_s(&quot;%d&quot;, &amp;k);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:需要明确一个优先级顺序：()&gt;[]&gt;<br>所以：<br>(*p)[n]：根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针；&#x2F;&#x2F;这是一个指向n个一维数组的指针<br><em>p[n]：根据优先级，先看[]，则p是一个数组，再结合</em>，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。&#x2F;&#x2F;这是一个以指针为其中元素的数组</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="初识指针"><a href="#初识指针" class="headerlink" title="初识指针"></a>初识指针</h2><h3 id="指针的定义："><a href="#指针的定义：" class="headerlink" title="指针的定义："></a>指针的定义：</h3><p>(我个人理解)指针就是一个特殊的存放地址的变量,一般用*p表示</p>
<h3 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：</span><br><span class="line">(1)int*ptr;//指针的类型是int*</span><br><span class="line">(2)char*ptr;//指针的类型是char*</span><br><span class="line">(3)int**ptr;//指针的类型是int**</span><br><span class="line">(4)int(*ptr)[3];//指针的类型是int(*)[3]</span><br><span class="line">(5)int*(*ptr)[4];//指针的类型是int*(*)[4]</span><br></pre></td></tr></table></figure>
<h3 id="指针所指向的类型"><a href="#指针所指向的类型" class="headerlink" title="指针所指向的类型"></a>指针所指向的类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</span><br><span class="line">从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：</span><br><span class="line">(1)int*ptr; //指针所指向的类型是int</span><br><span class="line">(2)char*ptr; //指针所指向的的类型是char</span><br><span class="line">(3)int**ptr; //指针所指向的的类型是int*</span><br><span class="line">(4)int(*ptr)[3]; //指针所指向的的类型是int()[3]</span><br><span class="line">(5)int*(*ptr)[4]; //指针所指向的的类型是int*()[4]</span><br></pre></td></tr></table></figure>
<p><strong>记得区分开指针类型和指针指向的类型</strong></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&amp;为取地址符,*为取值符</span><br><span class="line">&amp;运算符： int *p;</span><br><span class="line">          p=&amp;c;//将c的地址覆给指针变量p，称p为指向c的指针</span><br><span class="line">* 运算符：作用于指针时表示访问指针所指向的对象</span><br><span class="line">int x;   </span><br><span class="line">x = *p;  //将p指向的地址所对应的对象赋值给x，所以 x 就等于c的值</span><br><span class="line">scanf(&quot; %d&quot;, &amp;i);里的&amp;为一个运算符</span><br><span class="line">获得变量的地址，它的操作数必须是变量</span><br><span class="line">int i;</span><br><span class="line">printf(&quot;%x”&quot; ,&amp;i);</span><br><span class="line">由sizeof()求出的地址大小是否与int相同取决于编译器的架构</span><br><span class="line">如果是32位架构则相等即4个字节,64位则不等为8个字节，指针的大小与类型无关(目前对架构还不太理解,当成结论在记)</span><br></pre></td></tr></table></figure>
<p>4.指针可近似理解为一个取地址运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">printf(&quot;%p&quot;,&amp;i);//这里要用%p，且i要前加上一个取地址运算符</span><br><span class="line">//该程序运算的结果将不再是输出i=0而是输出i所在的地址,以16进制数的方式输出并且会在前方加上一个0x</span><br></pre></td></tr></table></figure>
<p>5.在指针中各个变量都是紧挨着存放在一个”堆栈”中的,变量的地址根据输入的先后由上往下排,但都相差4,即一个int字符的大小<br>6.”*”在指针中为一个新的单目运算符，用来访问指针的值所表示的地址上的变量</p>
<h3 id="指针应用场景："><a href="#指针应用场景：" class="headerlink" title="指针应用场景："></a>指针应用场景：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.利用swap函数交换两个数的值</span><br><span class="line">void swap(int *pa,int *pb)</span><br><span class="line">&#123;</span><br><span class="line">    int t=*pa;</span><br><span class="line">    *pa=*pb;</span><br><span class="line">    *pb=t;//利用指针进行变量的交换</span><br><span class="line">&#125;</span><br><span class="line">2.</span><br><span class="line">函数返回多个值，某些值就只能通过指针返回</span><br><span class="line">传入的参数实际上是需要保存带回的结果的变量</span><br><span class="line">3.</span><br><span class="line">函数返回运算的状态，结果通过指针返回</span><br><span class="line">常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错:</span><br><span class="line">通常返回值为-1或0 (在文件操作会看到大量的例子)</span><br><span class="line">但是当任何数值都是有效的可能结果时，就得分开返回了</span><br></pre></td></tr></table></figure>
<p>4.<strong>一定要给指针变量一个明确指向的地方</strong><br>5.数组变量是特殊的指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数组变量是特殊的指针</span><br><span class="line">●数组变量本身表达地址，所以</span><br><span class="line">●int a[10]; int*p=a; /无需用&amp;取地址</span><br><span class="line">●但是数组的单元表达的是变量，需要用&amp;取地址</span><br><span class="line">●a== &amp;a[0]</span><br><span class="line">●[]运算符可以对数组做，也可以对指针做:</span><br><span class="line">●p[0]&lt;==&gt; a[0]</span><br><span class="line">●*运算符可以对指针做，也可以对数组做:</span><br><span class="line">●*a= 25;</span><br></pre></td></tr></table></figure>
<p>7.指针是const</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">指针是const</span><br><span class="line">●表示一旦得到了某个变量的地址，不能再指向其他变量</span><br><span class="line">●int* const q=&amp;i;// q是const</span><br><span class="line">●*q= 26;// OK，由于i不是const，所以可以改变</span><br><span class="line">●q++;// ERROR由于q是const，故不能对q做运算</span><br></pre></td></tr></table></figure>
<h2 id="对指针类型的理解"><a href="#对指针类型的理解" class="headerlink" title="对指针类型的理解"></a>对指针类型的理解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int p; //这是一个普通的整型变量 </span><br><span class="line">int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针 </span><br><span class="line">int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组 </span><br><span class="line">int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组 </span><br><span class="line">int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针 </span><br><span class="line">int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 </span><br><span class="line">Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针 </span><br><span class="line">int* p_int; //指向int类型变量的指针</span><br><span class="line">double* p_double; //指向idouble类型变量的指针</span><br><span class="line">struct Student *p_struct; //结构体类型的指针</span><br><span class="line">int(*p_func)(int,int); //指向返回类型为int，有2个int形参的函数的指针</span><br><span class="line">int(*p_arr)[3]; //指向含有3个int元素的数组的指针</span><br><span class="line">int** p_pointer; //指向 一个整形变量指针的指针</span><br></pre></td></tr></table></figure>

<p>8.在结构体中,结构变量的名字不是结构变量的地址,在进行取地址运算时必须加上&amp;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">● 指针是内存地址 </span><br><span class="line">●  指针变量是存储内存地址的变量 </span><br><span class="line">●  指针变量与普通变量的定义方法一样,一种类型的普通变量的地址必须由同种类型的指针变量来存储</span><br></pre></td></tr></table></figure>

<p> <strong>什么是指针？:</strong> (我个人理解)指针就是一个特殊的存放地址的变量,一般用*p表示<br> <strong>什么是指针变量:</strong>  存放地址的变量称为指针变量。指针变量是一种特殊的变量，它不同于一般的变量，一般变量存放的是数据本身，而指针变量存放的是数据的地址。<br><strong>定义指针变量的一般形式为：</strong> 类型名 *指针变量<br><strong>如何使用指针变量：</strong> 只需要把被指向的变量的地址赋给指针变量即可使指针变量赋给另一个变量<br>**指针和指针变量的区别:**指针就是地址，地址就是指针,指针变量就是存放内存地址的变量<br><strong>什么是指针类型</strong>：</p>
<h2 id="对指针类型的理解-1"><a href="#对指针类型的理解-1" class="headerlink" title="对指针类型的理解"></a>对指针类型的理解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int p; //这是一个普通的整型变量 </span><br><span class="line">int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针 </span><br><span class="line">int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组 </span><br><span class="line">int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组 </span><br><span class="line">int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针 </span><br><span class="line">int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 </span><br><span class="line">Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针 </span><br></pre></td></tr></table></figure>
<p><strong>指针类型起到什么作用：</strong>(我个人认为)是指明了对应的地址的类型<br>通过调试来理解指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;   </span><br><span class="line">int x=0,y=0;</span><br><span class="line">int  *p;</span><br><span class="line">p=&amp;x;</span><br><span class="line">*p=10;</span><br><span class="line">printf(&quot;%d %d\n&quot;,x,y);</span><br><span class="line">p=&amp;y;</span><br><span class="line">*p=20;</span><br><span class="line">printf(&quot;%d %d\n&quot;,x,y);</span><br><span class="line">p=&amp;x;</span><br><span class="line">x=100;</span><br><span class="line">printf(&quot;%d\n&quot;,*p);</span><br><span class="line">p=&amp;y;</span><br><span class="line">y=200;</span><br><span class="line">printf(&quot;%d\n&quot;,*p);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//个人理解：这些运算基本等价于赋值</span><br><span class="line">//第一步是p给x赋值，同理第二步是对y赋值 </span><br><span class="line">//后来是利用&quot;取值符&quot;来对p赋值 </span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h2><p><strong>总述</strong>：链表是一种物理存储单元上非连续、非顺序的存储结构。数据元素的逻辑顺序是通过链表中的指针链接次序实现的<br>**帮助理解(指针)**：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量</p>
<h3 id="1-1-定义："><a href="#1-1-定义：" class="headerlink" title="1.1 定义："></a>1.1 <strong>定义</strong>：</h3><p>链表是一种常见的基础数据结构，结构体指针在这里得到了充分的利用。链表可以<strong>动态</strong>的进行存储分配，也就是说，链表是一个功能极为强大的数组，他可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点。</p>
<h3 id="1-2-组成："><a href="#1-2-组成：" class="headerlink" title="1.2 组成："></a>1.2 <strong>组成</strong>：</h3><p>链表都有一个头指针，一般以head来表示，存放的是一个地址。链表中的节点分为两类，<strong>头结点</strong>和<strong>一般节点</strong>，头结点是没有数据域的。链表中每个节点都分为两部分，一个<strong>数据域</strong>，一个是<strong>指针域</strong>。 ( <strong>理解</strong>：为了表示每个数据元素与其直接后继数据元素之间的逻辑关系，我们需要存出一个其直接后继的存储位置。我们把存储数据元素信息的域成为数据域，把存储后继位置的域称为指针域，这两部分构成一个节点) 链表就如同车链子一样，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放一个“NULL”（表示“空地址”），链表到此结束。</p>
<h2 id="2-单向链表"><a href="#2-单向链表" class="headerlink" title="2.单向链表"></a>2.单向链表</h2><h3 id="2-1-初学链表，一般从单向链表开始"><a href="#2-1-初学链表，一般从单向链表开始" class="headerlink" title="2.1 初学链表，一般从单向链表开始"></a>2.1 初学链表，一般从单向链表开始</h3><p>这是一个<strong>空链表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---&gt;NULL</span><br><span class="line">head</span><br></pre></td></tr></table></figure>
<p>有n个节点的链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ----&gt;[p1]----&gt;[p2]...----&gt;[pn]----&gt;[NULL]</span><br><span class="line">head   p1-&gt;next  p2-&gt;next   pn-&gt;next</span><br></pre></td></tr></table></figure>
<h3 id="2-2-定义一个链表"><a href="#2-2-定义一个链表" class="headerlink" title="2.2 定义一个链表"></a>2.2 定义一个链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct student&#123;</span><br><span class="line">    int score;</span><br><span class="line">    struct student *next;</span><br><span class="line">&#125; LinkList;</span><br></pre></td></tr></table></figure>
<p>一般创建链表我们都用<strong>typedef  struct</strong>，因为这样定义<strong>结构体变量</strong>时，我们就可以直接可以用LinkList  *a;定义结构体类型变量了。</p>
<h3 id="2-3-链表的初始化"><a href="#2-3-链表的初始化" class="headerlink" title="2.3 链表的初始化"></a>2.3 链表的初始化</h3><p>n为链表节点个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkList *creat(int n)&#123;</span><br><span class="line">    LinkList *head, *node, *end;//定义头节点，普通节点，尾部节点；</span><br><span class="line">    head = (LinkList*)malloc(sizeof(LinkList));//分配地址</span><br><span class="line">    end = head;         //若是空链表则头尾节点一样</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        node = (LinkList*)malloc(sizeof(LinkList));</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;node-&gt;score);//获取这个指针所指向的结构里的内容就要用到 -&gt; （结构体，类，共同体等）取成员运算符</span><br><span class="line">        end-&gt;next = node;</span><br><span class="line">        end = node;</span><br><span class="line">    &#125;</span><br><span class="line">    end-&gt;next = NULL;//结束创建</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-修改链表节点值"><a href="#2-4-修改链表节点值" class="headerlink" title="2.4 修改链表节点值"></a>2.4 修改链表节点值</h3><p>修改链表节点值很简单,一般通过定义一个函数来实现,如下<br>下面是一个传入链表和要修改的节点，来修改值的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void change(LinkList *list,int n) &#123;//n为第n个节点</span><br><span class="line">    LinkList *t = list;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while (i &lt; n &amp;&amp; t != NULL) &#123;</span><br><span class="line">        t = t-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (t != NULL) &#123;</span><br><span class="line">        puts(&quot;输入要修改的值&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;t-&gt;score);&gt;//获取这个指针所指向的结构里的内容就要用到 -&gt; （结构体，类，共同体等）取成员运算符</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        puts(&quot;节点不存在&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>1.文件是指一组数据的集合，可以被存储在计算机的磁盘或其他存储介质上。在C语言中，文件是通过指向FILE类型的指针来表示。<br>2.在C语言中，文件操作主要包括打开、读取、写入和关闭。打开文件时需要指定文件名和打开模式，可用的打开模式包括只读、只写、追加等。读取和写入文件时，可以使用fread()和fwrite()函数进行二进制读写，也可以使用fgets()和fputs()函数进行文本读写。<br>3.在C语言中，文件输入输出函数使用较多的是标准库中的fopen()、fclose()、fscanf()、fprintf()、fgets()、fputs()等函数。这些函数的使用方法和参数含义需要掌握。-<br>4.文件在使用完毕后需要关闭，以释放资源和确保数据写入磁盘。在C语言中，<strong>使用fclose()函数来关闭打开的文件</strong>。<br>5.文件操作时需要注意文件的打开模式和是否成功打开，以及文件是否正常关闭。在出现异常情况时，需要进行错误处理，例如检查文件指针是否为NULL等。<br>6.在C语言中，可以使用二进制文件读写和文本文件读写两种方式。二进制文件读写适用于任意类型的数据，而文本文件读写适用于文本格式的数据。<br>7.C语言中提供了一些函数，如feof()、ferror()等，用于检查文件是否到达文件结尾或是否发生错误等。在进行文件操作时，需要进行错误处理和异常情况处理，以确保程序正常运行。</p>
<h2 id="c-心得"><a href="#c-心得" class="headerlink" title="c++心得"></a>c++心得</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>1.一般情况下<br> #include<iostream>就够用<br>2.要用取整函数比如<br>ceil(m)   上取整 返回大于m的最大整数<br>Floor(m)  下取整 返回小于m的最大整数<br>Round(m) 四舍五入 返回m的四舍五入的整数<br>要引入#include<cmath>或#include&lt;math.h&gt;<br>3.为了使用setw()来设置域宽，也可以用setprecision()来控制浮点数的整体输出宽度，和fixed配合可以精确控制小数点后位数，setw()同时还可以设置输出时在语句前加上空格<br>要引入#include<iomanip><br>例如 double a&#x3D;123.456789&#x2F;&#x2F;double 为申请浮点数，类似int<br>cout&lt;&lt;setprecision(1)&lt;&lt;fixed&lt;&lt;a&lt;&lt;endl  &#x2F;&#x2F;就是小数点后保留一位<br>4.计算幂函数时要引入    #include<cmath><br>5.计算随机函数时要引入   #include<cstdlib><br>6.计算随机函数时要引入   #include<ctime></p>
<h3 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h3><p>1.标准输入输出：</p>
<p>标准库定义了4个IO对象。<br>为了处理输入，我们使用一个名为<strong>cin</strong> (发音为see-in)的istream类型的对象。<br>这个对象也被称为标准输入(standard input)。<br>对于输出，我们使用一个名为<strong>cout</strong> (发音为see-out)的ostream 类型的对象。<br>此对象也被称为标准输出( standard output)。<br>标准库还定义了其他两个ostream对象，名为<strong>cerr</strong>和<strong>clog</strong> (发音分别为see err和see-log)。<br>我们通常用cerr来输出警告和错误消息，因此它也被称为标准错误(standard error)。而clog用来输出程序运行时的一般性信息。<br>系统通常将程序所运行的窗口与这些对象关联起来。因此，当我们读取cin.数据将从程序正在运行的窗口读入，当我们向cout、cerr和clog写入数据时，将会写到同一个窗口。<br>2.三位数颠倒时<br>个位数为0的时候可能不符合题目<br>要求就直接输出这三位数，不用组装<br>类似cout&lt;&lt;ge&lt;&lt;shi&lt;&lt;bai&lt;&lt;endl;<br>3.强制转化浮点数和字母时可用<br> cout&lt;&lt;int(c1)&lt;&lt;endl;<br>     cout&lt;&lt;char(n2)&lt;&lt;endl;&#x2F;&#x2F;强制转换字符类型<br>4.定义一个常数用const double (+常数)<br>5.相等一定要用&#x3D;&#x3D;表示<br>6.随机函数种子用 srand(time(0)) 表示  &#x2F;&#x2F;表示以电脑当前时间为随机变量产生随机数<br>7.要产生某个范围内的随机数  e.g:  a-b:rand()%(b-a+1)+a<br>8.continue:{跳过本次循环体中尚未执行的语句}<br>         {提前结束本次循环}<br>         {直接开始下一次的循环判断}<br>9.do–while语句：  do{循环体条件}    while(条件为假，跳出循环)&#x2F;&#x2F;及条件为真的时候一直循环执行do括号内的条件&#x2F;&#x2F;替换单纯的while语句可能出现的语句重复，保证每条语句都能正常执行，注意while括号内的条件要反着写<br>10.幂函数用pow(x,y)表示x的y次方<br>11.fabs()函数可求一个浮点数的绝对值，abs()函数可求一个整数的绝对值<br>12.两个小数点后位数很多的数大小不能直接比较，系统输入的数可能存在一定误差，应用其相减的绝对值与一个极小的数做对比，常用10的-6次方（极小的数）常用1e-9表示<br>&lt;加上头文件#include<cmath>&gt;<br>13.当istream读入的数为<strong>无效流</strong>时会使istream对象的状态变为假，而无效状态的对象会使条件变为假&#x2F;&#x2F;定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">无效流: </span><br><span class="line">1. 读取到EOF文件结束符</span><br><span class="line">2. 读取无效输入(此例 value是一个int, 如果读到一个abc什么的, is就会无效)</span><br></pre></td></tr></table></figure>
<h3 id="当型循环和直到型循环对比"><a href="#当型循环和直到型循环对比" class="headerlink" title="当型循环和直到型循环对比"></a>当型循环和直到型循环对比</h3><p> 当型(while)：<br>先判断条件，再决定是否执行循环体<br>循环体的条件可能一次都不执行(即输入条件为真时跳过循环)<br>也可能存在某条语句的重复<br>while语句后不能加分号<br> 直到型(do……while):<br>先执行循环体，再判断条件<br>循环体最少执行一次<br>while语句后必须加分号<br>一般不会存在重复语句<br>这两种循环在某些特殊时候可以与for循环相互转化</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/09/hello-world/"
    >Hello World</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/09/hello-world/" class="article-date">
  <time datetime="2023-07-09T14:13:53.486Z" itemprop="datePublished">2023-07-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="楚盏"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>